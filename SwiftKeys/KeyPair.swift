//
//  KeyPair.swift
//  SwiftKeys
//
//  Created by Benjamin P Toews on 2/9/17.
//  Copyright Â© 2017 GitHub. All rights reserved.
//

import Foundation

public class KeyPair {
    class var keyType: SecAttrKeyType { return SecAttrKeyType.EC }

    // Count keys of this type generated by this keychain.
    public static func count(keychain: Keychain = Keychain.shared) -> Int? {
        return keychain.count(keyType: keyType)
    }
    
    // Delete keys of this type generated by this keychain.
    public static func delete(keychain: Keychain = Keychain.shared) -> Bool {
        return keychain.delete(keyType: keyType)
    }
    
    public let keychain: Keychain
    public let applicationLabel: Data
    public let privateKey: SecKey
    public let publicKey: SecKey
    
    // Application tag stores arbitrary data.
    public var applicationTag: Data? {
        get {
            return keychain.getSecItemAttr(attrAppLabel: applicationLabel, keyType: type(of: self).keyType, keyClass: .Public, attr: .ApplicationTag)
        }
        
        set {
            let value = (newValue ?? Data()) as CFData
            keychain.setSecItemAttr(attrAppLabel: applicationLabel, keyType: type(of: self).keyType, keyClass: .Public, attr: .ApplicationTag, value: value)
        }
    }
    
    // Raw bytes of the public key.
    public var publicKeyData: Data? {
        return keychain.getSecItemData(attrAppLabel: applicationLabel, keyType: type(of: self).keyType, keyClass: .Public)
    }
    
    // Find the keypair using it's application label.
    public init?(applicationLabel: Data, keychain: Keychain = Keychain.shared) {
        guard let priv = keychain.getSecKey(attrAppLabel: applicationLabel, keyType: type(of: self).keyType, keyClass: .Private) else {
            return nil
        }
        
        guard let pub = keychain.getSecKey(attrAppLabel: applicationLabel, keyType: type(of: self).keyType, keyClass: .Public) else {
            return nil
        }
        
        self.applicationLabel = applicationLabel
        self.privateKey = priv
        self.publicKey = pub
        self.keychain = keychain
    }
    
    // Generate a new key pair.
    public init?(size: Int, protection: SecAttrAccessible, flags: SecAccessControlCreateFlags = [], keychain: Keychain = Keychain.shared) {
        guard let acl = keychain.generateACL(protection: protection, flags: flags) else {
            return nil
        }
        
        guard let (pub, priv) = keychain.generateKeyPair(keyType: type(of: self).keyType, keySize: size, acl: acl) else {
            return nil
        }
        
        guard let appLabel: Data = keychain.getSecKeyAttr(key: pub, attr: .ApplicationLabel) else {
            return nil
        }
        
        self.applicationLabel = appLabel
        self.privateKey = priv
        self.publicKey = pub
        self.keychain = keychain
        
    }
    
    // Delete this key pair from the keychain.
    public func delete() -> Bool {
        return keychain.delete(attrAppLabel: applicationLabel)
    }
    
    // Sign some data with the private key using some algorithm.
    public func sign(_ data: Data, algorithm: SecKeyAlgorithm) -> Data? {
        return keychain.sign(key: privateKey, data: data, algorithm: algorithm)
    }
    
    // Verify signature over some data with the public key using some algorithm.
    public func verify(data: Data, signature: Data, algorithm: SecKeyAlgorithm) -> Bool {
        return keychain.verify(key: publicKey, data: data, signature: signature, algorithm: algorithm)
    }
}
