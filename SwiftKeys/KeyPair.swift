//
//  KeyPair.swift
//  SwiftKeys
//
//  Created by Benjamin P Toews on 2/9/17.
//  Copyright Â© 2017 GitHub. All rights reserved.
//

import Foundation

public protocol KeyPair {
    static var keyType: SecAttrKeyType { get }
    static var keySize: Int { get }
    
    // Count keys of this type generated by this keychain.
    static func count(keychain: Keychain) -> Int?
    
    // Delete keys of this type generated by this keychain.
    static func delete(keychain: Keychain) -> Bool

    var keychain: Keychain { get }
    var applicationLabel: Data { get }
    var privateKey: SecKey { get }
    var publicKey: SecKey { get }
    
    // Application tag stores arbitrary data.
    var applicationTag: Data? { get set }
    
    // Raw bytes of the public key.
    var publicKeyData: Data? { get }
    
    // Find the keypair using it's application label.
    init?(applicationLabel: Data, keychain: Keychain)
    
    // Generate a new keypair.
    init?(protection: SecAttrAccessible, isPermanent: Bool, keychain: Keychain)
    
    init(applicationLabel: Data, privateKey: SecKey, publicKey: SecKey, keychain: Keychain)
    
    // Delete this key pair from the keychain.
    func delete() -> Bool
    
    // Sign some data with the private key using some algorithm.
    func sign(_ data: Data, algorithm: SecKeyAlgorithm) -> Data?
    
    // Verify signature over some data with the public key using some algorithm.
    func verify(data: Data, signature: Data, algorithm: SecKeyAlgorithm) -> Bool
}

extension KeyPair {
    // Count keys of this type generated by this keychain.
    public static func count(keychain: Keychain = Keychain.shared) -> Int? {
        return keychain.count(keyType: keyType)
    }
    
    // Delete keys of this type generated by this keychain.
    public static func delete(keychain: Keychain = Keychain.shared) -> Bool {
        return keychain.delete(keyType: keyType)
    }
    
    // Application tag stores arbitrary data.
    public var applicationTag: Data? {
        get {
            return keychain.getSecItemAttr(attrAppLabel: applicationLabel, keyType: Self.keyType, keyClass: .Public, attr: .ApplicationTag)
        }
        
        set {
            let value = (newValue ?? Data()) as CFData
            keychain.setSecItemAttr(attrAppLabel: applicationLabel, keyType: Self.keyType, keyClass: .Public, attr: .ApplicationTag, value: value)
        }
    }

    // Raw bytes of the public key.
    public var publicKeyData: Data? {
        return keychain.getSecItemData(attrAppLabel: applicationLabel, keyType: Self.keyType, keyClass: .Public)
    }
    
    // Find the keypair using it's application label.
    public init?(applicationLabel: Data, keychain: Keychain = Keychain.shared) {
        guard let priv = keychain.getSecKey(attrAppLabel: applicationLabel, keyClass: .Private) else {
            return nil
        }

        guard let pub = keychain.getSecKey(attrAppLabel: applicationLabel, keyClass: .Public) else {
            return nil
        }
        
        self.init(applicationLabel: applicationLabel, privateKey: priv, publicKey: pub, keychain: keychain)
    }
    
    // Generate a new key pair.
    public init?(protection: SecAttrAccessible, isPermanent: Bool = true, keychain: Keychain = Keychain.shared) {
        guard let acl = keychain.generateACL(protection: protection) else {
            return nil
        }
        
        guard let (pub, priv) = keychain.generateKeyPair(keyType: Self.keyType, keySize: Self.keySize, isPermanent: isPermanent, acl: acl) else {
            return nil
        }
        
        guard let appLabel: Data = keychain.getSecKeyAttr(key: pub, attr: .ApplicationLabel) else {
            return nil
        }
        
        self.init(applicationLabel: appLabel, privateKey: priv, publicKey: pub, keychain: keychain)
        
    }
    
    // Delete this key pair from the keychain.
    public func delete() -> Bool {
        return keychain.delete(attrAppLabel: applicationLabel)
    }
    
    // Sign some data with the private key using some algorithm.
    public func sign(_ data: Data, algorithm: SecKeyAlgorithm) -> Data? {
        return keychain.sign(key: privateKey, data: data, algorithm: algorithm)
    }
    
    // Verify signature over some data with the public key using some algorithm.
    public func verify(data: Data, signature: Data, algorithm: SecKeyAlgorithm) -> Bool {
        return keychain.verify(key: publicKey, data: data, signature: signature, algorithm: algorithm)
    }
}
